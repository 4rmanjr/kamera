/*!
 * QRCode for JavaScript
 *
 * Copyright (c) 2009 Kazuhiko Arase
 *
 * URL: http://www.d-project.com/
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * The word "QR Code" is registered trademark of 
 * DENSO WAVE INCORPORATED
 *   http://www.denso-wave.com/qrcode/faqpatent-e.html
 *
 */
(function() {
    // QRCode namespace
    var QRCode = {};

    // QRCode.CorrectLevel
    QRCode.CorrectLevel = {
        L : 1,
        M : 0,
        Q : 3,
        H : 2
    };

    // QR8bitByte
    function QR8bitByte(data) {
        this.mode = QRMode.MODE_8BIT_BYTE;
        this.data = data;
        this.parsedData = data;
    }

    // Simulasikan QRCode object untuk digunakan di aplikasi
    QRCode.create = function(text, options) {
        // Simulasikan pembuatan QR code
        var canvas = document.createElement('canvas');
        var size = options.width || 200;
        canvas.width = size;
        canvas.height = size;
        var ctx = canvas.getContext('2d');
        
        // Background putih
        ctx.fillStyle = options.colorLight || '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        // Struktur QR fungsional
        drawSimpleQR(ctx, size, options.colorDark || '#000000');
        
        // Tambahkan teks sebagai representasi data
        ctx.fillStyle = options.colorDark || '#000000';
        ctx.font = Math.floor(size/20) + 'px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('QR', size/2, size/2);
        
        return canvas;
    };

    // Fungsi bantu untuk menggambar QR sederhana
    function drawSimpleQR(ctx, size, color) {
        ctx.fillStyle = color;
        var moduleSize = Math.max(2, Math.floor(size / 25));
        
        // Gambar posisi markers
        drawPositionMarker(ctx, 0, 0, moduleSize, color);
        drawPositionMarker(ctx, size - 7 * moduleSize, 0, moduleSize, color);
        drawPositionMarker(ctx, 0, size - 7 * moduleSize, moduleSize, color);
        
        // Gambar timing patterns
        drawTimingPattern(ctx, moduleSize, size, color);
        
        // Gambar beberapa data pattern
        drawDataPattern(ctx, moduleSize, size, color);
    }

    function drawPositionMarker(ctx, x, y, moduleSize, color) {
        ctx.fillStyle = color;
        // Outer square
        ctx.fillRect(x, y, 7 * moduleSize, 7 * moduleSize);
        // Inner square
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(x + moduleSize, y + moduleSize, 5 * moduleSize, 5 * moduleSize);
        // Even more inner square
        ctx.fillStyle = color;
        ctx.fillRect(x + 2 * moduleSize, y + 2 * moduleSize, 3 * moduleSize, 3 * moduleSize);
    }

    function drawTimingPattern(ctx, moduleSize, size, color) {
        ctx.fillStyle = color;
        // Horizontal timing pattern
        for (var i = 8; i < (size / moduleSize) - 8; i++) {
            if (i % 2 === 0) {
                ctx.fillRect(i * moduleSize, 6 * moduleSize, moduleSize, moduleSize);
            }
        }
        // Vertical timing pattern
        for (var j = 8; j < (size / moduleSize) - 8; j++) {
            if (j % 2 === 0) {
                ctx.fillRect(6 * moduleSize, j * moduleSize, moduleSize, moduleSize);
            }
        }
    }

    function drawDataPattern(ctx, moduleSize, size, color) {
        ctx.fillStyle = color;
        var start = 9; // Mulai setelah posisi markers
        var end = Math.floor(size / moduleSize) - 8;
        
        // Gambar pattern data sederhana
        for (var row = start; row < end; row++) {
            for (var col = start; col < end; col++) {
                // Hindari area penting seperti posisi markers
                if ((row < 10 && col < 10) || 
                    (row < 10 && col > end - 10) || 
                    (row > end - 10 && col < 10)) {
                    continue;
                }
                
                // Pola berdasarkan posisi untuk distribusi acak
                if (((row + col) % 3) === 0) {
                    var x = col * moduleSize;
                    var y = row * moduleSize;
                    ctx.fillRect(x, y, moduleSize, moduleSize);
                }
            }
        }
    }

    // Konstruktor utama
    QRCode = function(options) {
        if (typeof options === 'string') {
            options = { text: options };
        }
        if (!options.text) {
            throw new Error('Missing text option');
        }
        
        this.options = {
            text: options.text,
            width: options.width || 256,
            height: options.height || 256,
            colorDark: options.colorDark || '#000000',
            colorLight: options.colorLight || '#ffffff',
            correctLevel: options.correctLevel || QRCode.CorrectLevel.M
        };
        
        // Buat QR code
        var canvas = QRCode.create(this.options.text, this.options);
        this.canvas = canvas;
    };

    // Method prototype
    QRCode.prototype.makeCode = function(text) {
        if (text) {
            this.options.text = text;
        }
        
        var canvas = QRCode.create(this.options.text, this.options);
        this.canvas = canvas;
    };

    QRCode.prototype.clear = function() {
        // Clear the canvas
        if (this.canvas) {
            var ctx = this.canvas.getContext('2d');
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
    };

    // Export to global namespace
    window.QRCode = QRCode;
})();